---
layout: default
title: Xcode中OC新特性
---
{{ page.title }}
=============
{{ page.date | date: "%Y-%m-%d" }}

本文主要mark一下收集到的Xcode中OC的一些新特性

一、XCode4.4以后：

1.以前我们使用NSNumber、NSArray和NSDictionary是这样的：

	NSNumber *number = [NSNumber numberWithInt:100];
    NSArray *array = [NSArray arrayWithObjects:@"a", @"b", @"c", nil];
    NSDictionary *dict = [NSDictionary dictionaryWithObjectsAndKeys:
                          @"v1", @"k1",
                          @"v2", @"k2",
                          @"v3", @"k3", nil];
    NSArray *emptyArray = [NSArray array];
    NSDictionary *emptyDict = [NSDictionary dictionary];
    [array objectAtIndex:index] 
    [array replaceObjectAtIndex:index withObject:obj]

现在可以这样更简洁的声明和初始化：
    
	NSNumber *number = @100;
    NSArray *array = @[@"a", @"b", @"c"];
    NSDictionary *dict = @{@"k1":@"v1", @"k2":@"v2", @"k3":@"v3"};
    NSArray *emptyArray = @[];
    NSDictionary *emptyDict = @{};
    array[index];
    array[index] = obj;

在NSArray和NSDictionary不需要再用nil来表示结束了。

2.以前的enum是这样的：
	typedef enum {
	    spring,
	    summer,
	    autumn,
	    winter
	} Season;

后来可以定义enum是无符号整数还是整数，编译器可以更加智能的做类型检查。
	typedef enum Season : NSInteger {
	    spring,
	    summer,
	    autumn,
	    winter
	}Season;

推荐使用新的固定的基础类型定义，因它有更强大的的类型检查和代码补全。 SDK现在有一个宏来鼓励和促进使用固定类型定义 - NS_ENUM()：

	typedef NS_ENUM(NSUInteger, Season) {
    	spring,
	    summer,
	    autumn,
	    winter
	};

3.可以使用block来遍历数组和字典：

	NSArray *array = @[@"1", @"2", @"3"];
    [array enumerateObjectsUsingBlock:
     ^(id obj, NSUInteger idx, BOOL *stop) {
        NSLog(@"%i-%@", idx, obj);
         
    }];

    NSDictionary *dict = @{@"k1":@"v1", @"k2":@"v2", @"k3":@"v3"};
    [dict enumerateKeysAndObjectsUsingBlock:
     ^(id key, id obj, BOOL *stop) {
        NSLog(@"%@=%@", key, obj);
    }];

二、2015 OC新特性Xcode 7中 

http://blog.sunnyxx.com/2015/06/12/objc-new-features-in-2015/

1.泛型

这家伙在Java里早就有了。

	NSArray<NSString *> *strings = @[@"sun", @"yuan"];
	NSDictionary<NSString *, NSNumber *> *mapping = @{@"a": @1, @"b": @2};
	@property (readonly) NSArray *imageURLs;
	@property (readonly) NSArray<NSURL *> *imageURLs;

2.__kindof

我理解的是这种类型的一种。

	- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier;
	- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier;

这个方法以前的返回值是所有，但其实这个方法只会返回UITableViewCell及它的子类，现在这个类型被稍微细化了，(__kindof UITableViewCell *)这样写就代表后者，这样的话不需要强制转换类型了。

	
	@property (nonatomic, readonly, copy) NSArray<__kindof UIView *> *subviews;
    UIButton *button = view.subviews.lastObject;

因为现在数组里面装的类型是UIView及其子类，那么现在去数组最后一个元素赋值给UIButton，不需要强制转换了，UIButton就是UIView的子类。

3.Nullability-简化版的Optional



