---
layout: default
title: Xcode中的两个疑惑（OC私有实例变量声明的位置和@synthesize的使用）
---
{{ page.title }}
=============
{{ page.date | date: "%Y-%m-%d" }}

本文主要谈日常使用Xcode开发中遇到的两个疑惑。

一、Xcode中OC私有实例变量声明的位置

在Xcode中新建一个Class叫Test，会生成Test.h和Test.m两个文件，那么这个类的私有的实例变量应该声明在哪里？我以前看过的至少有3个地方是可以的：

1.在Test.h中，下面这样：

    @interface Test : NSObject{
        NSString *str;
    }
    @end

2.在Test.m的@interface中：

    #import "Test.h"

	@interface Test (){
        NSString *str;
	}
	@end

	@implementation Test

	@end

3.同样在Test.m中，不过这次是在@implementation中：

	#import "Test.h"

	@interface Test ()

	@end

	@implementation Test{
	    NSString *str;
	}
	@end

这个问题一直困扰着我，最近在http://blog.devtang.com/blog/2015/03/15/ios-dev-controversy-1/找到了原因，mark一下原因，以下内容来自前面的这个博文：

在 Objective-C 的语言的早期，类的私有成员变量是只能定义在 .h 的头文件里面的。像如下这样：

	@interface ViewController : UIViewController {
        @private
        NSInteger _value;
	}

之后，苹果改进了 Objective-C，允许在 .m 里面添加一个特殊的匿名 Category，即没有名字的 Category，来实现增加类的成员变量。像如下这样：

	@interface ViewController ()

	@property (nonatomic) NSInteger value;

	@end

这样的好处是，这些变量在头文件中被彻底隐藏起来了，不用暴露给使用者。

接着，在 2013 年的 WWDC 中，苹果进一步改进了 Objective-C，允许在 .m 的 @implementation 中直接添加类的私有成员变量。像如下这样：

	@implementation ViewController {
        NSInteger _value;
	}

最后他的建议是在@implementation中声明，详细原因可以参见http://blog.devtang.com/blog/2015/03/15/ios-dev-controversy-1/。

二、Xcode中@synthesize的使用

这个问题其实是没有跟上编译器新特性的问题，为什么这么说呢？因为在Xcode 4.5以前我们看到的常规做法是这样的：

Test.h

	#import <Foundation/Foundation.h>

	@interface Test : NSObject{
        NSString *_str;
	}

	@property (nonatomic, copy) NSString *str;

	@end

Test.m

	#import "Test.h"
	@interface Test ()

	@end

	@implementation Test

	@synthesize str = _str;

	@end

如果你还在使用上面的方法来使用@property和@synthesize的话，说明你的用法已经过时了，因为在Xcode 4.4以后增加了一个新特性Automatic Property Synthesize，现在你只需这样：

Test.h

	#import <Foundation/Foundation.h>

	@interface Test : NSObject

	@property (nonatomic, copy) NSString *str;

	@end

Test.m

	#import "Test.h"
	@interface Test ()

	@end

	@implementation Test

	@end

对的，你没看错，现在已经不需要写@synthesize了，因为编译器会在编译时自动给你加上，所以你在源文件里是看不到的，另外编译器还会自动为你生成一个叫_str（@property里的名称前面加_）的实例变量，一行代码就搞定了。

不过需要说明的一点是：以前的@property和@synthesize这种用法在一种情况下还是需要用，那就是你的实例变量的名称并不是@property里的名称前面加_，那么还是需要@property和@synthesize成对配合使用，比如你的实例变量名字加_str，但是你的getter和setter的名字分别想叫name和SetName:，不过我想一般不会有这种要求。

